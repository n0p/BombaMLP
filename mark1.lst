CCS PCM C Compiler, Version 4.038, 64747               07-dic-10 02:08

               Filename: D:\My Dropbox\bomba MLP\mark1.lst

               ROM used: 852 words (10%)
                         Largest free fragment is 2048
               RAM used: 31 (8%) at main() level
                         43 (12%) worst case
               Stack:    5 locations

*
0000:  MOVLW  00
0001:  MOVWF  0A
0002:  GOTO   29B
0003:  NOP
.................... #include "mark1.h" 
.................... #include <16F877A.h> 
.................... //////// Standard Header file for the PIC16F877A device //////////////// 
.................... #device PIC16F877A 
.................... #list 
....................  
.................... #device adc=8 
....................  
.................... #FUSES NOWDT                 	//No Watch Dog Timer 
.................... #FUSES HS                    	//High speed Osc (> 4mhz) 
.................... #FUSES NOPUT                 	//No Power Up Timer 
.................... #FUSES NOPROTECT             	//Code not protected from reading 
.................... #FUSES NODEBUG               	//No Debug mode for ICD 
.................... #FUSES BROWNOUT              	//Reset when brownout detected 
.................... #FUSES NOLVP                 	//No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOCPD                 	//No EE protection 
.................... #FUSES NOWRT                 	//Program memory not write protected 
....................  
.................... #use delay(clock=20000000) 
*
0094:  MOVLW  3C
0095:  MOVWF  04
0096:  BCF    03.7
0097:  MOVF   00,W
0098:  BTFSC  03.2
0099:  GOTO   0A7
009A:  MOVLW  06
009B:  MOVWF  78
009C:  CLRF   77
009D:  DECFSZ 77,F
009E:  GOTO   09D
009F:  DECFSZ 78,F
00A0:  GOTO   09C
00A1:  MOVLW  7B
00A2:  MOVWF  77
00A3:  DECFSZ 77,F
00A4:  GOTO   0A3
00A5:  DECFSZ 00,F
00A6:  GOTO   09A
00A7:  RETLW  00
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8) 
....................  
....................  
....................  
....................  
.................... #define LCD_TYPE 2; 
.................... #include <lcd.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCDD.C                                //// 
.................... ////                 Driver for common LCD modules                     //// 
.................... ////                                                                   //// 
.................... ////  lcd_init()   Must be called before any other function.           //// 
.................... ////                                                                   //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.     //// 
.................... ////                     The following have special meaning:           //// 
.................... ////                      \f  Clear display                            //// 
.................... ////                      \n  Go to start of second line               //// 
.................... ////                      \b  Move back one position                   //// 
.................... ////                                                                   //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)    //// 
.................... ////                                                                   //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD         //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... // As defined in the following structure the pin connection is as follows: 
.................... //     D0  enable 
.................... //     D1  rs 
.................... //     D2  rw 
.................... //     D4  D4 
.................... //     D5  D5 
.................... //     D6  D6 
.................... //     D7  D7 
.................... // 
.................... //   LCD pins D0-D3 are not used and PIC D3 is not used. 
....................  
.................... // Un-comment the following define to use port B 
.................... // #define use_portb_lcd TRUE 
....................  
....................  
.................... struct lcd_pin_map {                 // This structure is overlayed 
....................            BOOLEAN enable;           // on to an I/O port to gain 
....................            BOOLEAN rs;               // access to the LCD pins. 
....................            BOOLEAN rw;               // The bits are allocated from 
....................            BOOLEAN unused;           // low order up.  ENABLE will 
....................            int     data : 4;         // be pin B0. 
....................         } lcd; 
....................  
....................  
.................... #if defined use_portb_lcd 
....................    //#locate lcd = getenv("sfr:PORTB")    // This puts the entire structure over the port 
....................    #ifdef __pch__ 
....................     #locate lcd = 0xf81 
....................    #else 
....................     #locate lcd = 6 
....................    #endif 
....................    #define set_tris_lcd(x) set_tris_b(x) 
.................... #else 
....................    //#locate lcd = getenv("sfr:PORTD")    // This puts the entire structure over the port 
....................    #ifdef __pch__ 
....................     #locate lcd = 0xf83 
....................    #else 
....................     #locate lcd = 8 
....................    #endif 
....................    #define set_tris_lcd(x) set_tris_d(x) 
.................... #endif 
....................  
....................  
.................... #define lcd_type 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #define lcd_line_two 0x40    // LCD RAM address for the second line 
....................  
....................  
.................... BYTE const LCD_INIT_STRING[4] = {0x20 | (lcd_type << 2), 0xc, 1, 6}; 
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................  
....................  
....................                              // The following are used for setting 
....................                              // the I/O port direction register. 
....................  
.................... struct lcd_pin_map const LCD_WRITE = {0,0,0,0,0}; // For write mode all pins are out 
.................... struct lcd_pin_map const LCD_READ = {0,0,0,0,15}; // For read mode data pins are in 
....................  
....................  
....................  
.................... BYTE lcd_read_byte() { 
....................       BYTE low,high; 
....................       set_tris_lcd(LCD_READ); 
*
00B8:  MOVLW  F0
00B9:  BSF    03.5
00BA:  MOVWF  08
....................       lcd.rw = 1; 
00BB:  BCF    03.5
00BC:  BSF    08.2
....................       delay_cycles(1); 
00BD:  NOP
....................       lcd.enable = 1; 
00BE:  BSF    08.0
....................       delay_cycles(1); 
00BF:  NOP
....................       high = lcd.data; 
00C0:  MOVF   08,W
00C1:  SWAPF  08,W
00C2:  ANDLW  0F
00C3:  MOVWF  43
....................       lcd.enable = 0; 
00C4:  BCF    08.0
....................       delay_cycles(1); 
00C5:  NOP
....................       lcd.enable = 1; 
00C6:  BSF    08.0
....................       delay_us(1); 
00C7:  GOTO   0C8
00C8:  GOTO   0C9
00C9:  NOP
....................       low = lcd.data; 
00CA:  MOVF   08,W
00CB:  SWAPF  08,W
00CC:  ANDLW  0F
00CD:  MOVWF  42
....................       lcd.enable = 0; 
00CE:  BCF    08.0
....................       set_tris_lcd(LCD_WRITE); 
00CF:  MOVLW  00
00D0:  BSF    03.5
00D1:  MOVWF  08
....................       return( (high<<4) | low); 
00D2:  BCF    03.5
00D3:  SWAPF  43,W
00D4:  MOVWF  77
00D5:  MOVLW  F0
00D6:  ANDWF  77,F
00D7:  MOVF   77,W
00D8:  IORWF  42,W
00D9:  MOVWF  78
.................... } 
....................  
....................  
.................... void lcd_send_nibble( BYTE n ) { 
....................       lcd.data = n; 
*
00A8:  SWAPF  43,W
00A9:  ANDLW  F0
00AA:  MOVWF  77
00AB:  MOVLW  0F
00AC:  ANDWF  08,W
00AD:  IORWF  77,W
00AE:  MOVWF  08
....................       delay_cycles(1); 
00AF:  NOP
....................       lcd.enable = 1; 
00B0:  BSF    08.0
....................       delay_us(2); 
00B1:  MOVLW  03
00B2:  MOVWF  77
00B3:  DECFSZ 77,F
00B4:  GOTO   0B3
....................       lcd.enable = 0; 
00B5:  BCF    08.0
.................... } 
00B6:  RETLW  00
....................  
....................  
.................... void lcd_send_byte( BYTE address, BYTE n ) { 
....................  
....................       lcd.rs = 0; 
00B7:  BCF    08.1
....................       while ( bit_test(lcd_read_byte(),7) ) ; 
*
00DA:  MOVF   78,W
00DB:  MOVWF  42
00DC:  BTFSC  42.7
00DD:  GOTO   0B8
....................       lcd.rs = address; 
00DE:  BTFSS  40.0
00DF:  BCF    08.1
00E0:  BTFSC  40.0
00E1:  BSF    08.1
....................       delay_cycles(1); 
00E2:  NOP
....................       lcd.rw = 0; 
00E3:  BCF    08.2
....................       delay_cycles(1); 
00E4:  NOP
....................       lcd.enable = 0; 
00E5:  BCF    08.0
....................       lcd_send_nibble(n >> 4); 
00E6:  SWAPF  41,W
00E7:  MOVWF  42
00E8:  MOVLW  0F
00E9:  ANDWF  42,F
00EA:  MOVF   42,W
00EB:  MOVWF  43
00EC:  CALL   0A8
....................       lcd_send_nibble(n & 0xf); 
00ED:  MOVF   41,W
00EE:  ANDLW  0F
00EF:  MOVWF  42
00F0:  MOVWF  43
00F1:  CALL   0A8
.................... } 
00F2:  RETLW  00
....................  
....................  
.................... void lcd_init() { 
....................     BYTE i; 
....................     set_tris_lcd(LCD_WRITE); 
00F3:  MOVLW  00
00F4:  BSF    03.5
00F5:  MOVWF  08
....................     lcd.rs = 0; 
00F6:  BCF    03.5
00F7:  BCF    08.1
....................     lcd.rw = 0; 
00F8:  BCF    08.2
....................     lcd.enable = 0; 
00F9:  BCF    08.0
....................     delay_ms(15); 
00FA:  MOVLW  0F
00FB:  MOVWF  3C
00FC:  CALL   094
....................     for(i=1;i<=3;++i) { 
00FD:  MOVLW  01
00FE:  MOVWF  38
00FF:  MOVF   38,W
0100:  SUBLW  03
0101:  BTFSS  03.0
0102:  GOTO   10B
....................        lcd_send_nibble(3); 
0103:  MOVLW  03
0104:  MOVWF  43
0105:  CALL   0A8
....................        delay_ms(5); 
0106:  MOVLW  05
0107:  MOVWF  3C
0108:  CALL   094
....................     } 
0109:  INCF   38,F
010A:  GOTO   0FF
....................     lcd_send_nibble(2); 
010B:  MOVLW  02
010C:  MOVWF  43
010D:  CALL   0A8
....................     for(i=0;i<=3;++i) 
010E:  CLRF   38
010F:  MOVF   38,W
0110:  SUBLW  03
0111:  BTFSS  03.0
0112:  GOTO   11C
....................        lcd_send_byte(0,LCD_INIT_STRING[i]); 
0113:  MOVF   38,W
0114:  CALL   004
0115:  MOVWF  39
0116:  CLRF   40
0117:  MOVF   39,W
0118:  MOVWF  41
0119:  CALL   0B7
011A:  INCF   38,F
011B:  GOTO   10F
.................... } 
011C:  BCF    0A.3
011D:  BCF    0A.4
011E:  GOTO   2B4 (RETURN)
....................  
....................  
.................... void lcd_gotoxy( BYTE x, BYTE y) { 
....................    BYTE address; 
....................  
....................    if(y!=1) 
011F:  DECFSZ 3D,W
0120:  GOTO   122
0121:  GOTO   125
....................      address=lcd_line_two; 
0122:  MOVLW  40
0123:  MOVWF  3E
....................    else 
0124:  GOTO   126
....................      address=0; 
0125:  CLRF   3E
....................    address+=x-1; 
0126:  MOVLW  01
0127:  SUBWF  3C,W
0128:  ADDWF  3E,F
....................    lcd_send_byte(0,0x80|address); 
0129:  MOVF   3E,W
012A:  IORLW  80
012B:  MOVWF  3F
012C:  CLRF   40
012D:  MOVF   3F,W
012E:  MOVWF  41
012F:  CALL   0B7
.................... } 
0130:  RETLW  00
....................  
.................... void lcd_putc(char c) { 
....................    switch (c) { 
0131:  MOVF   3B,W
0132:  XORLW  0C
0133:  BTFSC  03.2
0134:  GOTO   13C
0135:  XORLW  06
0136:  BTFSC  03.2
0137:  GOTO   144
0138:  XORLW  02
0139:  BTFSC  03.2
013A:  GOTO   14A
013B:  GOTO   14F
....................      case '\f'   : lcd_send_byte(0,1); 
013C:  CLRF   40
013D:  MOVLW  01
013E:  MOVWF  41
013F:  CALL   0B7
....................                    delay_ms(2); 
0140:  MOVLW  02
0141:  MOVWF  3C
0142:  CALL   094
....................                                            break; 
0143:  GOTO   155
....................      case '\n'   : lcd_gotoxy(1,2);        break; 
0144:  MOVLW  01
0145:  MOVWF  3C
0146:  MOVLW  02
0147:  MOVWF  3D
0148:  CALL   11F
0149:  GOTO   155
....................      case '\b'   : lcd_send_byte(0,0x10);  break; 
014A:  CLRF   40
014B:  MOVLW  10
014C:  MOVWF  41
014D:  CALL   0B7
014E:  GOTO   155
....................      default     : lcd_send_byte(1,c);     break; 
014F:  MOVLW  01
0150:  MOVWF  40
0151:  MOVF   3B,W
0152:  MOVWF  41
0153:  CALL   0B7
0154:  GOTO   155
....................    } 
.................... } 
0155:  RETLW  00
....................  
.................... char lcd_getc( BYTE x, BYTE y) { 
....................    char value; 
....................  
....................     lcd_gotoxy(x,y); 
....................     while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................     lcd.rs=1; 
....................     value = lcd_read_byte(); 
....................     lcd.rs=0; 
....................     return(value); 
.................... } 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(int *)==1 
.................... #define ptrdiff_t int 
.................... #else 
.................... #define ptrdiff_t long 
.................... #endif 
....................  
.................... #define size_t int 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
....................    Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1*/ 
....................  
.................... char *strcopy(char *s1, char *s2) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; *s2 != 0; s++, s2++) { 
....................      *s = *s2; 
....................   } 
....................   *s = *s2; 
....................   return(s1); 
.................... } 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   int n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,int c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, int c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... int *strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, int c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... int *strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
02AE:  BCF    03.5
02AF:  CLRF   20
02B0:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(int errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... int *strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define LED_VERDE PIN_D3 
.................... #define LED_ROJO PIN_C3 
.................... #define PIEZO PIN_C4 
....................  
.................... long cuentas; 
....................  
.................... char cuenta[18]; 
....................  
.................... void armar(); 
.................... void detona(); 
....................  
.................... void main() 
.................... { 
*
029B:  CLRF   04
029C:  BCF    03.7
029D:  MOVLW  1F
029E:  ANDWF  03,F
029F:  MOVLW  81
02A0:  BSF    03.5
02A1:  MOVWF  19
02A2:  MOVLW  A6
02A3:  MOVWF  18
02A4:  MOVLW  90
02A5:  BCF    03.5
02A6:  MOVWF  18
02A7:  BSF    03.5
02A8:  BSF    1F.0
02A9:  BSF    1F.1
02AA:  BSF    1F.2
02AB:  BCF    1F.3
02AC:  MOVLW  07
02AD:  MOVWF  1C
....................  
....................    lcd_init(); 
*
02B3:  GOTO   0F3
....................  
....................    setup_adc_ports(NO_ANALOGS); 
02B4:  BSF    03.5
02B5:  BSF    1F.0
02B6:  BSF    1F.1
02B7:  BSF    1F.2
02B8:  BCF    1F.3
....................    setup_adc(ADC_OFF); 
02B9:  BCF    03.5
02BA:  BCF    1F.0
....................    setup_psp(PSP_DISABLED); 
02BB:  BSF    03.5
02BC:  BCF    09.4
....................    setup_spi(SPI_SS_DISABLED); 
*
02B1:  MOVLW  FF
02B2:  MOVWF  36
*
02BD:  BCF    03.5
02BE:  BCF    14.5
02BF:  BCF    36.5
02C0:  MOVF   36,W
02C1:  BSF    03.5
02C2:  MOVWF  07
02C3:  BCF    03.5
02C4:  BSF    36.4
02C5:  MOVF   36,W
02C6:  BSF    03.5
02C7:  MOVWF  07
02C8:  BCF    03.5
02C9:  BCF    36.3
02CA:  MOVF   36,W
02CB:  BSF    03.5
02CC:  MOVWF  07
02CD:  MOVLW  01
02CE:  BCF    03.5
02CF:  MOVWF  14
02D0:  MOVLW  00
02D1:  BSF    03.5
02D2:  MOVWF  14
....................    setup_timer_0(RTCC_INTERNAL|RTCC_DIV_256); 
02D3:  MOVF   01,W
02D4:  ANDLW  C0
02D5:  IORLW  07
02D6:  MOVWF  01
....................    setup_timer_1(T1_DISABLED); 
02D7:  BCF    03.5
02D8:  CLRF   10
....................    setup_timer_2(T2_DISABLED,0,1); 
02D9:  MOVLW  00
02DA:  MOVWF  78
02DB:  MOVWF  12
02DC:  MOVLW  00
02DD:  BSF    03.5
02DE:  MOVWF  12
....................    setup_comparator(NC_NC_NC_NC); 
02DF:  MOVLW  07
02E0:  MOVWF  1C
02E1:  MOVF   05,W
02E2:  MOVLW  10
02E3:  MOVWF  77
02E4:  DECFSZ 77,F
02E5:  GOTO   2E4
02E6:  NOP
02E7:  MOVF   1C,W
02E8:  BCF    03.5
02E9:  BCF    0D.6
....................    setup_vref(FALSE); 
02EA:  BSF    03.5
02EB:  CLRF   1D
....................  
....................    output_low(PIEZO); 
02EC:  BCF    03.5
02ED:  BCF    36.4
02EE:  MOVF   36,W
02EF:  BSF    03.5
02F0:  MOVWF  07
02F1:  BCF    03.5
02F2:  BCF    07.4
....................    output_low(LED_ROJO); 
02F3:  BCF    36.3
02F4:  MOVF   36,W
02F5:  BSF    03.5
02F6:  MOVWF  07
02F7:  BCF    03.5
02F8:  BCF    07.3
....................    output_high(LED_VERDE); 
02F9:  BSF    03.5
02FA:  BCF    08.3
02FB:  BCF    03.5
02FC:  BSF    08.3
....................    delay_ms(100); 
02FD:  MOVLW  64
02FE:  MOVWF  3C
02FF:  CALL   094
....................     
....................    lcd_putc('\f'); 
0300:  MOVLW  0C
0301:  MOVWF  3B
0302:  CALL   131
....................    lcd_putc("    SISTEMA\n    ACTIVADO"); 
0303:  CLRF   38
0304:  MOVF   38,W
0305:  CALL   00C
0306:  IORLW  00
0307:  BTFSC  03.2
0308:  GOTO   30D
0309:  INCF   38,F
030A:  MOVWF  3B
030B:  CALL   131
030C:  GOTO   304
....................     
....................    while (1) 
....................    { 
....................       delay_ms(100); 
030D:  MOVLW  64
030E:  MOVWF  3C
030F:  CALL   094
....................       output_toggle(LED_ROJO); 
0310:  BCF    36.3
0311:  MOVF   36,W
0312:  BSF    03.5
0313:  MOVWF  07
0314:  MOVLW  08
0315:  BCF    03.5
0316:  XORWF  07,F
....................       if( !input(PIN_A0) ) { 
0317:  BSF    03.5
0318:  BSF    05.0
0319:  BCF    03.5
031A:  BTFSC  05.0
031B:  GOTO   328
....................          delay_ms(500); 
031C:  MOVLW  02
031D:  MOVWF  38
031E:  MOVLW  FA
031F:  MOVWF  3C
0320:  CALL   094
0321:  DECFSZ 38,F
0322:  GOTO   31E
....................          if (!input(PIN_A0)) 
0323:  BSF    03.5
0324:  BSF    05.0
0325:  BCF    03.5
0326:  BTFSS  05.0
....................             break; 
0327:  GOTO   329
....................       } 
....................    } 
0328:  GOTO   30D
....................     
....................    output_low(LED_ROJO); 
0329:  BCF    36.3
032A:  MOVF   36,W
032B:  BSF    03.5
032C:  MOVWF  07
032D:  BCF    03.5
032E:  BCF    07.3
....................    lcd_putc('\f'); 
032F:  MOVLW  0C
0330:  MOVWF  3B
0331:  CALL   131
....................    lcd_putc("    DETONADOR\n     ARMADO"); 
0332:  CLRF   38
0333:  MOVF   38,W
0334:  CALL   029
0335:  IORLW  00
0336:  BTFSC  03.2
0337:  GOTO   33C
0338:  INCF   38,F
0339:  MOVWF  3B
033A:  CALL   131
033B:  GOTO   333
....................                                                       
....................    while (1) 
....................    { 
....................       delay_ms(200); 
033C:  MOVLW  C8
033D:  MOVWF  3C
033E:  CALL   094
....................       output_toggle(LED_VERDE); 
033F:  BSF    03.5
0340:  BCF    08.3
0341:  MOVLW  08
0342:  BCF    03.5
0343:  XORWF  08,F
....................       if( input(PIN_A0) ) { 
0344:  BSF    03.5
0345:  BSF    05.0
0346:  BCF    03.5
0347:  BTFSS  05.0
0348:  GOTO   352
....................          delay_ms(200); // para falsos positivos 
0349:  MOVLW  C8
034A:  MOVWF  3C
034B:  CALL   094
....................          if (input(PIN_A0)) 
034C:  BSF    03.5
034D:  BSF    05.0
034E:  BCF    03.5
034F:  BTFSS  05.0
0350:  GOTO   352
....................             armar(); 
0351:  GOTO   17B
....................       } 
....................    } 
0352:  GOTO   33C
....................  
.................... } 
....................  
.................... int segundos; 
....................  
0353:  SLEEP
.................... void armar() 
.................... { 
....................    output_high(LED_VERDE); 
*
017B:  BSF    03.5
017C:  BCF    08.3
017D:  BCF    03.5
017E:  BSF    08.3
....................    output_high(LED_ROJO); 
017F:  BCF    36.3
0180:  MOVF   36,W
0181:  BSF    03.5
0182:  MOVWF  07
0183:  BCF    03.5
0184:  BSF    07.3
....................    lcd_putc("\f  CUENTA ATRAS:\n"); 
0185:  CLRF   38
0186:  MOVF   38,W
0187:  CALL   047
0188:  IORLW  00
0189:  BTFSC  03.2
018A:  GOTO   18F
018B:  INCF   38,F
018C:  MOVWF  3B
018D:  CALL   131
018E:  GOTO   186
....................    for (cuentas=9900;cuentas>0;cuentas--) 
018F:  MOVLW  26
0190:  MOVWF  23
0191:  MOVLW  AC
0192:  MOVWF  22
0193:  MOVF   22,F
0194:  BTFSS  03.2
0195:  GOTO   199
0196:  MOVF   23,F
0197:  BTFSC  03.2
0198:  GOTO   263
....................    { 
....................       lcd_gotoxy(4,2); 
0199:  MOVLW  04
019A:  MOVWF  3C
019B:  MOVLW  02
019C:  MOVWF  3D
019D:  CALL   11F
....................       //lcd_putc(48+(cuentas/10000)%10); 
....................       lcd_putc(48+(cuentas/1000)%10); 
019E:  MOVF   23,W
019F:  MOVWF  3B
01A0:  MOVF   22,W
01A1:  MOVWF  3A
01A2:  MOVLW  03
01A3:  MOVWF  3D
01A4:  MOVLW  E8
01A5:  MOVWF  3C
01A6:  CALL   156
01A7:  MOVF   79,W
01A8:  MOVWF  39
01A9:  MOVF   78,W
01AA:  MOVWF  38
01AB:  MOVF   79,W
01AC:  MOVWF  3B
01AD:  MOVF   78,W
01AE:  MOVWF  3A
01AF:  CLRF   3D
01B0:  MOVLW  0A
01B1:  MOVWF  3C
01B2:  CALL   156
01B3:  MOVF   77,W
01B4:  ADDLW  30
01B5:  MOVWF  39
01B6:  MOVF   7A,W
01B7:  MOVWF  3A
01B8:  BTFSC  03.0
01B9:  INCF   3A,F
01BA:  MOVF   39,W
01BB:  MOVWF  3B
01BC:  CALL   131
....................       lcd_putc(48+(cuentas/100)%10); 
01BD:  MOVF   23,W
01BE:  MOVWF  3B
01BF:  MOVF   22,W
01C0:  MOVWF  3A
01C1:  CLRF   3D
01C2:  MOVLW  64
01C3:  MOVWF  3C
01C4:  CALL   156
01C5:  MOVF   79,W
01C6:  MOVWF  39
01C7:  MOVF   78,W
01C8:  MOVWF  38
01C9:  MOVF   79,W
01CA:  MOVWF  3B
01CB:  MOVF   78,W
01CC:  MOVWF  3A
01CD:  CLRF   3D
01CE:  MOVLW  0A
01CF:  MOVWF  3C
01D0:  CALL   156
01D1:  MOVF   77,W
01D2:  ADDLW  30
01D3:  MOVWF  39
01D4:  MOVF   7A,W
01D5:  MOVWF  3A
01D6:  BTFSC  03.0
01D7:  INCF   3A,F
01D8:  MOVF   39,W
01D9:  MOVWF  3B
01DA:  CALL   131
....................       lcd_putc("."); 
01DB:  CLRF   38
01DC:  MOVF   38,W
01DD:  CALL   05D
01DE:  IORLW  00
01DF:  BTFSC  03.2
01E0:  GOTO   1E5
01E1:  INCF   38,F
01E2:  MOVWF  3B
01E3:  CALL   131
01E4:  GOTO   1DC
....................       lcd_putc(48+(cuentas/10)%10); 
01E5:  MOVF   23,W
01E6:  MOVWF  3B
01E7:  MOVF   22,W
01E8:  MOVWF  3A
01E9:  CLRF   3D
01EA:  MOVLW  0A
01EB:  MOVWF  3C
01EC:  CALL   156
01ED:  MOVF   79,W
01EE:  MOVWF  39
01EF:  MOVF   78,W
01F0:  MOVWF  38
01F1:  MOVF   79,W
01F2:  MOVWF  3B
01F3:  MOVF   78,W
01F4:  MOVWF  3A
01F5:  CLRF   3D
01F6:  MOVLW  0A
01F7:  MOVWF  3C
01F8:  CALL   156
01F9:  MOVF   77,W
01FA:  ADDLW  30
01FB:  MOVWF  39
01FC:  MOVF   7A,W
01FD:  MOVWF  3A
01FE:  BTFSC  03.0
01FF:  INCF   3A,F
0200:  MOVF   39,W
0201:  MOVWF  3B
0202:  CALL   131
....................       lcd_putc(48+cuentas%10); 
0203:  MOVF   23,W
0204:  MOVWF  3B
0205:  MOVF   22,W
0206:  MOVWF  3A
0207:  CLRF   3D
0208:  MOVLW  0A
0209:  MOVWF  3C
020A:  CALL   156
020B:  MOVF   77,W
020C:  ADDLW  30
020D:  MOVWF  38
020E:  MOVF   7A,W
020F:  MOVWF  39
0210:  BTFSC  03.0
0211:  INCF   39,F
0212:  MOVF   38,W
0213:  MOVWF  3B
0214:  CALL   131
....................       delay_ms(9); 
0215:  MOVLW  09
0216:  MOVWF  3C
0217:  CALL   094
....................       if (!(cuentas%(cuentas>1000?100:(cuentas>300?50:25)))) { 
0218:  MOVF   23,W
0219:  SUBLW  02
021A:  BTFSC  03.0
021B:  GOTO   225
021C:  XORLW  FF
021D:  BTFSS  03.2
021E:  GOTO   223
021F:  MOVF   22,W
0220:  SUBLW  E8
0221:  BTFSC  03.0
0222:  GOTO   225
0223:  MOVLW  64
0224:  GOTO   233
0225:  MOVF   23,W
0226:  SUBLW  00
0227:  BTFSC  03.0
0228:  GOTO   232
0229:  XORLW  FF
022A:  BTFSS  03.2
022B:  GOTO   230
022C:  MOVF   22,W
022D:  SUBLW  2C
022E:  BTFSC  03.0
022F:  GOTO   232
0230:  MOVLW  32
0231:  GOTO   233
0232:  MOVLW  19
0233:  MOVWF  38
0234:  MOVF   23,W
0235:  MOVWF  3B
0236:  MOVF   22,W
0237:  MOVWF  3A
0238:  CLRF   3D
0239:  MOVF   38,W
023A:  MOVWF  3C
023B:  CALL   156
023C:  MOVF   77,W
023D:  IORWF  7A,W
023E:  BTFSS  03.2
023F:  GOTO   25E
....................          output_toggle(LED_ROJO); 
0240:  BCF    36.3
0241:  MOVF   36,W
0242:  BSF    03.5
0243:  MOVWF  07
0244:  MOVLW  08
0245:  BCF    03.5
0246:  XORWF  07,F
....................          output_toggle(PIEZO); 
0247:  BCF    36.4
0248:  MOVF   36,W
0249:  BSF    03.5
024A:  MOVWF  07
024B:  MOVLW  10
024C:  BCF    03.5
024D:  XORWF  07,F
....................          delay_ms(100); 
024E:  MOVLW  64
024F:  MOVWF  3C
0250:  CALL   094
....................          output_toggle(PIEZO); 
0251:  BCF    36.4
0252:  MOVF   36,W
0253:  BSF    03.5
0254:  MOVWF  07
0255:  MOVLW  10
0256:  BCF    03.5
0257:  XORWF  07,F
....................          cuentas-=10; 
0258:  MOVLW  0A
0259:  SUBWF  22,F
025A:  MOVLW  00
025B:  BTFSS  03.0
025C:  MOVLW  01
025D:  SUBWF  23,F
....................       } 
....................    } 
025E:  MOVF   22,W
025F:  BTFSC  03.2
0260:  DECF   23,F
0261:  DECF   22,F
0262:  GOTO   193
....................    detona(); 
.................... } 
*
0298:  BCF    0A.3
0299:  BCF    0A.4
029A:  GOTO   352 (RETURN)
....................  
.................... void detona() 
.................... { 
....................    lcd_putc("\f"); 
*
0263:  CLRF   38
0264:  MOVF   38,W
0265:  CALL   063
0266:  IORLW  00
0267:  BTFSC  03.2
0268:  GOTO   26D
0269:  INCF   38,F
026A:  MOVWF  3B
026B:  CALL   131
026C:  GOTO   264
....................    lcd_putc("  WTF BOOOOOM!  \n"); 
026D:  CLRF   38
026E:  MOVF   38,W
026F:  CALL   069
0270:  IORLW  00
0271:  BTFSC  03.2
0272:  GOTO   277
0273:  INCF   38,F
0274:  MOVWF  3B
0275:  CALL   131
0276:  GOTO   26E
....................    lcd_putc("  (has muerto)  "); 
0277:  CLRF   38
0278:  MOVF   38,W
0279:  CALL   07F
027A:  IORLW  00
027B:  BTFSC  03.2
027C:  GOTO   281
027D:  INCF   38,F
027E:  MOVWF  3B
027F:  CALL   131
0280:  GOTO   278
....................    while (1) { 
....................       delay_ms(50); 
0281:  MOVLW  32
0282:  MOVWF  3C
0283:  CALL   094
....................       output_toggle(LED_VERDE); 
0284:  BSF    03.5
0285:  BCF    08.3
0286:  MOVLW  08
0287:  BCF    03.5
0288:  XORWF  08,F
....................       output_toggle(LED_ROJO); 
0289:  BCF    36.3
028A:  MOVF   36,W
028B:  BSF    03.5
028C:  MOVWF  07
028D:  MOVLW  08
028E:  BCF    03.5
028F:  XORWF  07,F
....................       output_toggle(PIEZO); 
0290:  BCF    36.4
0291:  MOVF   36,W
0292:  BSF    03.5
0293:  MOVWF  07
0294:  MOVLW  10
0295:  BCF    03.5
0296:  XORWF  07,F
....................    } 
0297:  GOTO   281
.................... } 

Configuration Fuses:
   Word  1: 3F7A   HS NOWDT NOPUT NODEBUG NOPROTECT BROWNOUT NOLVP NOCPD NOWRT
